import { SchemaComposer } from "../SchemaComposer";
import { loadManifest } from "../helpers/manifest";

import chalk from "chalk";
import fs, { readFileSync } from "fs";
import path from "path";
import Mustache from "mustache";
import {
  OutputDirectory,
  OutputEntry,
  writeDirectory,
} from "@web3api/schema-bind";
import { TypeInfo, parseSchema } from "@web3api/schema-parse";

export interface CodeGeneratorConfig {
  manifestPath: string;
  generationFile: string;
  outputDir: string;
  ensAddress?: string;
  ethProvider?: string;
  ipfsProvider?: string;
}

export class CodeGenerator {
  private _schema: string | undefined = "";
  constructor(private _config: CodeGeneratorConfig) {}

  public async generateCode(): Promise<boolean> {
    // Make sure that the output dir exists, if not create a new one
    if (!fs.existsSync(this._config.outputDir)) {
      fs.mkdirSync(this._config.outputDir);
    }

    // Compose schema from manifest
    const schemaComposer = new SchemaComposer(this._config);
    const manifest = await loadManifest(this._config.manifestPath);
    const composedSchema = await schemaComposer.composeSchemas(manifest);
    const typeInfo = parseSchema(composedSchema.combined || "");
    this._schema = composedSchema.combined;

    // Check the generation file if it has the proper run() method
    // eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports, @typescript-eslint/naming-convention
    const generator = await require(this._config.generationFile);
    if (!generator) {
      console.log(chalk.red("The generation file provided is wrong."));
      return false;
    }

    const { run } = generator;
    if (!run) {
      console.log(
        chalk.red("The generation file provided doesn't have the 'run' method.")
      );
      return false;
    }

    const output: OutputDirectory = {
      entries: [],
    };

    await run(output, {
      typeInfo,
      generate: (templatePath: string, typeInfo: TypeInfo) =>
        this.generate(templatePath, typeInfo),
    });

    output.entries = await Promise.all(
      output.entries.map((entry) => this.generateFile(entry, typeInfo))
    );

    writeDirectory(this._config.outputDir, output);

    console.log(`ðŸ”¥ Types were generated successfully ðŸ”¥`);
    return true;
  }

  public generate(templatePath: string, typeInfo: TypeInfo): string {
    templatePath = path.join(
      path.dirname(this._config.generationFile),
      templatePath
    );

    const template = readFileSync(templatePath);

    let content = Mustache.render(template.toString(), {
      typeInfo,
      schema: this._schema,
    });

    content = `// NOTE: This is generated by 'w3 codegen', DO NOT MODIFY

${content}
`;

    return content;
  }

  public async generateFile(
    entry: OutputEntry,
    typeInfo: TypeInfo
  ): Promise<OutputEntry> {
    if (entry.type === "Directory") {
      entry.data = await Promise.all(
        entry.data.map((subEntry) => this.generateFile(subEntry, typeInfo))
      );
    } else if (entry.type === "Template") {
      entry = {
        ...entry,
        data: this.generate(entry.data, typeInfo),
        type: "File",
      };
    }

    return entry;
  }
}
